#!/usr/bin/python

import argparse
import os
import re

HEADER_TMPL = """/////////////////////////////////////////////////////////
// Auto-generated by gen_rfnoc_inst.py! Any changes
// in this file will be overwritten the next time
// this script is run.
/////////////////////////////////////////////////////////
localparam NUM_CE = {num_ce};
wire [NUM_CE*64-1:0] ce_flat_o_tdata, ce_flat_i_tdata;
wire [63:0]          ce_o_tdata[0:NUM_CE-1], ce_i_tdata[0:NUM_CE-1];
wire [NUM_CE-1:0]    ce_o_tlast, ce_o_tvalid, ce_o_tready, ce_i_tlast, ce_i_tvalid, ce_i_tready;
wire [63:0]          ce_debug[0:NUM_CE-1];
// Flatten CE tdata arrays
genvar k;
generate
  for (k = 0; k < NUM_CE; k = k + 1) begin
    assign ce_o_tdata[k] = ce_flat_o_tdata[k*64+63:k*64];
    assign ce_flat_i_tdata[k*64+63:k*64] = ce_i_tdata[k];
  end
endgenerate
wire ce_clk = radio_clk;
wire ce_rst = radio_rst;
"""

BLOCK_TMPL = """
{blockname} {instname} (
  .bus_clk(bus_clk), .bus_rst(bus_rst),
  .ce_clk(ce_clk), .ce_rst(ce_rst),
  .i_tdata(ce_o_tdata[{n}]), .i_tlast(ce_o_tlast[{n}]), .i_tvalid(ce_o_tvalid[{n}]), .i_tready(ce_o_tready[{n}]),
  .o_tdata(ce_i_tdata[{n}]), .o_tlast(ce_i_tlast[{n}]), .o_tvalid(ce_i_tvalid[{n}]), .o_tready(ce_i_tready[{n}]),
  .debug(ce_debug[{n}])
);
"""

FILL_FIFO_TMPL = """
// Fill remaining crossbar ports with loopback FIFOs
genvar n;
generate
  for (n = {fifo_start}; n < NUM_CE; n = n + 1) begin
    noc_block_axi_fifo_loopback inst_noc_block_axi_fifo_loopback (
      .bus_clk(bus_clk), .bus_rst(bus_rst),
      .ce_clk(ce_clk), .ce_rst(ce_rst),
      .i_tdata(ce_o_tdata[n]), .i_tlast(ce_o_tlast[n]), .i_tvalid(ce_o_tvalid[n]), .i_tready(ce_o_tready[n]),
      .o_tdata(ce_i_tdata[n]), .o_tlast(ce_i_tlast[n]), .o_tvalid(ce_i_tvalid[n]), .o_tready(ce_i_tready[n]),
      .debug(ce_debug[n])
    );
  end
endgenerate
"""


def setup_parser():
    """
    Create argument parser
    """
    # Parse options

    # Args
    parser = argparse.ArgumentParser(
            description = "Generate the NoC block instantiation file",
            )
    parser.add_argument(
            "-I", "--include-dir", 
            help="Path directory of the RFNoC Out-of-Tree module",
            default="") #default put the gr-ettus folder maybe?
    parser.add_argument(
            "-m", "--max-num-blocks", type=int,
            help="Maximum number of blocks (Max. Allowed for x310|x300: 11, for e300:6)",
            default="11")
    parser.add_argument(
            "--fill-with-fifos",
            help="If the number of blocks provided was smaller than the max number, fill the rest with FIFOs",
            action="store true")
    parser.add_argument(
            "-o", "--outfile",
            help="Output filename",
    parser.add_argument(
            "-t", "--target", type="string",
            help="Target device [X310, X300, E310]",
            default="")
    parser.add_argument(
            "blocks",
            help="List block names to instantiate.",
            default="",
            nargs='*', #Means we collect them all, or none
            )
    return parser

def create_output(args):
    """
    Returns the verilogs
    """
    blocks= []
    for b in args.blocks:
        for _b in b.split(" "):
            blocks.append(_b.strip())
    if len(blocks) == 0:
        print "[GEN_RFNOC_INST ERROR] No blocks specified!"
        exit(1)
    if len(blocks) > args.max_num_blocks:
        print "[GEN_RFNOC_INST ERROR] Trying to connect {} blocks, mas is {}".format(len(blocks), args.max_num_blocks)
        exit(1)
    num_ce = args.max_num_blocks
    if not args.fill_with_fifos:
        num_ce = len(blocks)
    output = HEADER_TMPL.format(num_ce=num_ce)
    if len(args.outfile):
        print "--Using the following blocks to generate image:"
    block_count = {k: 0 for k in set(blocks)}
    for i, block in enumerate(blocks):
        block_count[block] += 1
        instname = "inst_{}{}".format(block, "" if block_count[block] == 1 else block_count[block])
        if len(args.outfile):
            print "    * {}".format(block)
        output += BLOCK_TMPL.format(blockname=block, instname=instname, n=i)
    if args.fill_with_fifos:
        output += FILL_FIFO_TMPL.format(fifo_start=len(blocks))
    return output

def create_env_var(args):
    """
    Generates an Environmental variable from the inserted
    RFNoC OOT module path, to be used in the include files
    for fpga-srcs
    """
    include_dir = args.include_dir
    if (include_dir == None):
        print('ERROR: Please specify a RFNoC OOT module path')
        exit(1)
    else if not os.path.isdir(include_dir):
        print('ERROR: The given directory does not exist or can not be found')
        parser.print_help()
        exit(1)
    os.putenv('RFNOC_INCLUDE_DIR', include_dir)
    target = args.target
    if (len(target) == 0):
        print('ERROR: Please specify a device target [X300, X310, E300]')
        exit(1)
    else if(target) not in ['X310','X300','E300','x310','x300','e300']:
        print('ERROR: Target device not recognized')
        exit(1)


if __name__ == "__main__":
    args = setup_parser().parse_args()
    RFNOC_BLOCKS = create_env_var(args)
    output = create_output(args)
    if (len(args.outfile):
        open(args.outfile,'w').write(output)
    else:
        print output


