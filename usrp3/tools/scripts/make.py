#!/usr/bin/python

import argparse
import os
import re
import subprocess

HEADER_TMPL = """/////////////////////////////////////////////////////////
// Auto-generated by gen_rfnoc_inst.py! Any changes
// in this file will be overwritten the next time
// this script is run.
/////////////////////////////////////////////////////////
localparam NUM_CE = {num_ce};
wire [NUM_CE*64-1:0] ce_flat_o_tdata, ce_flat_i_tdata;
wire [63:0]          ce_o_tdata[0:NUM_CE-1], ce_i_tdata[0:NUM_CE-1];
wire [NUM_CE-1:0]    ce_o_tlast, ce_o_tvalid, ce_o_tready, ce_i_tlast, ce_i_tvalid, ce_i_tready;
wire [63:0]          ce_debug[0:NUM_CE-1];
// Flatten CE tdata arrays
genvar k;
generate
  for (k = 0; k < NUM_CE; k = k + 1) begin
    assign ce_o_tdata[k] = ce_flat_o_tdata[k*64+63:k*64];
    assign ce_flat_i_tdata[k*64+63:k*64] = ce_i_tdata[k];
  end
endgenerate
wire ce_clk = radio_clk;
wire ce_rst = radio_rst;
"""

BLOCK_TMPL = """
noc_block_{blockname} {instname} (
  .bus_clk(bus_clk), .bus_rst(bus_rst),
  .ce_clk(ce_clk), .ce_rst(ce_rst),
  .i_tdata(ce_o_tdata[{n}]), .i_tlast(ce_o_tlast[{n}]), .i_tvalid(ce_o_tvalid[{n}]), .i_tready(ce_o_tready[{n}]),
  .o_tdata(ce_i_tdata[{n}]), .o_tlast(ce_i_tlast[{n}]), .o_tvalid(ce_i_tvalid[{n}]), .o_tready(ce_i_tready[{n}]),
  .debug(ce_debug[{n}])
);
"""

FILL_FIFO_TMPL = """
// Fill remaining crossbar ports with loopback FIFOs
genvar n;
generate
  for (n = {fifo_start}; n < NUM_CE; n = n + 1) begin
    noc_block_axi_fifo_loopback inst_noc_block_axi_fifo_loopback (
      .bus_clk(bus_clk), .bus_rst(bus_rst),
      .ce_clk(ce_clk), .ce_rst(ce_rst),
      .i_tdata(ce_o_tdata[n]), .i_tlast(ce_o_tlast[n]), .i_tvalid(ce_o_tvalid[n]), .i_tready(ce_o_tready[n]),
      .o_tdata(ce_i_tdata[n]), .o_tlast(ce_i_tlast[n]), .o_tvalid(ce_i_tvalid[n]), .o_tready(ce_i_tready[n]),
      .debug(ce_debug[n])
    );
  end
endgenerate
"""


def setup_parser():
    """
    Create argument parser
    """
    # Parse options
    # Args
    parser = argparse.ArgumentParser(
            description = "Generate the NoC block instantiation file",
            )
    parser.add_argument(
            "-I", "--include-dir", 
            help="Path directory of the RFNoC Out-of-Tree module",
            default="") #default put the gr-ettus folder maybe?
    parser.add_argument(
            "-m", "--max-num-blocks", type=int,
            help="Maximum number of blocks (Max. Allowed for x310|x300: 11, for e300:6)",
            default="11")
    parser.add_argument(
            "--fill-with-fifos",
            help="If the number of blocks provided was smaller than the max number, fill the rest with FIFOs",
            action="store_true")
    parser.add_argument(
            "-o", "--outfile",
            help="Output filename",)
    parser.add_argument(
            "-t", "--target",
            help="Target device [X310, X300, E310]",
            default="")
    parser.add_argument(
            "blocks",
            help="List block names to instantiate.",
            default="",
            nargs='*', #Means we collect them all, or none
            )
    return parser

def create_output(args):
    """
    Returns the verilogs
    """
    blocks= []
    for b in args.blocks:
        for _b in b.split(" "):
            blocks.append(_b.strip())
    if len(blocks) == 0:
        print "[GEN_RFNOC_INST ERROR] No blocks specified!"
        exit(1)
    if len(blocks) > args.max_num_blocks:
        print "[GEN_RFNOC_INST ERROR] Trying to connect {} blocks, mas is {}".format(len(blocks), args.max_num_blocks)
        exit(1)
    num_ce = args.max_num_blocks
    if not args.fill_with_fifos:
        num_ce = len(blocks)
    output = HEADER_TMPL.format(num_ce=num_ce)
    if len(args.outfile):
        print "--Using the following blocks to generate image:"
    block_count = {k: 0 for k in set(blocks)}
    for i, block in enumerate(blocks):
        block_count[block] += 1
        instname = "inst_{}{}".format(block, "" if block_count[block] == 1 else block_count[block])
        if len(args.outfile):
            print "    * {}".format(block)
        output += BLOCK_TMPL.format(blockname=block, instname=instname, n=i)
    if args.fill_with_fifos:
        output += FILL_FIFO_TMPL.format(fifo_start=len(blocks))
    return output

def file_generator(args,output):
    """
    Takes the target device as an argument and replaces the auto_ce file in the
    corresponding top folder
    """
    base_path= os.getcwd() #sets up the current working directory, regardless of pybombs or source install. This file is shipped at {prefix}/src/uhd/fpga-src/usrp3/tools
    print "Adding CE instantiation file for '%s'" %  args.target
    if (args.target=='e300'):
        path_to_file = base_path+'/../../top/e300/rfnoc_ce_auto_inst_e310.v' 
        open(path_to_file,'w').write(output)
    elif (args.target=='x300') or (args.target=='x310'):
        path_to_file = base_path+'/../../top/x300' 
        if (args.target=='x300'):
            path_ce = os.path.join(path_to_file, 'rfnoc_ce_auto_inst_x300.v')
        else:
            path_ce = os.path.join(path_to_file, 'rfnoc_ce_auto_inst_x310.v')
        open(path_ce,'w').write(output)
    #self.scm.add_files((path_to_file,)) # TODO: necessary? 

def create_env_var(args):
    """
    Generates an Environmental variable from the inserted
    RFNoC OOT module path, to be used in the include files
    for fpga-srcs
    """
    include_dir = args.include_dir
    if (include_dir == None):
        print('[GEN_RFNOC_INST ERROR]: Please specify a RFNoC OOT module path')
        exit(1)
    elif not (os.path.isdir(include_dir)):
        print('[GEN_RFNOC_INST ERROR]: The given directory does not exist or can not be found')
        include_dir= ""
        exit(1)
    #os.putenv('RFNOC_INCLUDE_DIR', include_dir) #replaced with return include dir
    target = args.target
    if (len(target) == 0):
        print('[GEN_RFNOC_INST ERROR]: Please specify a device target [x300, x310, e300]')
        exit(1)
    elif(target) not in ['x310','x300','e300']:
        print('[GEN_RFNOC_INST ERROR]: Target device not recognized')
        exit(1)
    return include_dir

def create_rfnoc_env_script(include_dir):
    """
    checks if the fpga-src has already an rfnoc_env_script and, if not,
    creates it *and sources it*.
    """
    src_dir = include_dir+"rfnoc/fpga-src"
    base_path= os.getcwd() #sets up the current working directory, regardless of pybombs or source install. This file is shipped at {prefix}/src/uhd/fpga-src/usrp3/tools
    if not (os.path.isfile('rfnoc_env')):
        print "no rfnoc_env file found. Setting it up..."
        open('rfnoc_env', 'w').write("export RFNOC_OOT=\\\n"
               +os.path.join(base_path,'..','..','lib','rfnoc',) + '\\\n')
    else: print "rfnoc_env file found!"
             #   {0}".format(os.path.join(base_path,'..','..','lib','rfnoc')+'\n\\'))
    dummy = "XXXX" #Used for appending always at the end of the line
    append_re_line_sequence('rfnoc_env',dummy,':'+src_dir)#TODO: it is not recognizing the pattern but actually that doesnt matter/

#include ../../lib/rfnoc/Makefile.srcs
#    else: print "rfnoc_env file found!"
    print "loading RFNoC path as enviroment variable"
    rfnoc_env_file = 'rfnoc_env'
    separator = '<<<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>>'
    env_cmd = "source ./{env_file} && echo '{sep}' && env".format(env_file=rfnoc_env_file, sep=separator)
    try:
        script_output = subprocess.check_output(env_cmd, shell=True)
    except subprocess.CalledProcessError as e:
        print "Trouble sourcing file {env_file}".format(env_file=rfnoc_env_file)
        exit(1)
    env_output = script_output.split(separator)[-1]
    env_output = env_output.split('\n')
    env = {}
    for env_line in env_output:
        env_line = env_line.strip()
        if len(env_line) == 0:
            continue
        k, v = env_line.split('=', 1)
        env[k] = v
    return env #TODO this is working as long as the script is running, but as soon as it stops, the env goes away. Sourcing manually temporarily, but thhere should be a fix to automate this

def load_env_from_script(rfnoc_env_file): #added to create_rfnoc_env_script
    """
    adds and sources the RFNoC OOT directory path to the enviroment
    """
    print "loading RFNoC path as enviroment variable"
    separator = '<<<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>>'
    env_cmd = "source ./{env_file} && echo '{sep}' && env".format(env_file=rfnoc_env_file, sep=separator)
    try:
        #script_output = subprocess.check_output(env_cmd, shell=True)
        os.system(env_cmd)
    except subprocess.CalledProcessorError as e:
        print "Trouble sourcing file {env_file}".format(env_file=rfnoc_env_file)
        exit(1)

def append_re_line_sequence(filename, linepattern, newline):
    """ Detects the re 'linepattern' in the file. After its last occurrence,
    paste 'newline'. If the pattern does not exist, append the new line
    to the file. Then, write. If the newline already exists, leaves the file
    unchanged"""
    oldfile = open(filename, 'r').read()
    lines = re.findall(newline, oldfile, flags=re.MULTILINE)
    if len(lines) != 0:
        pass
    else:
        pattern_lines = re.findall(linepattern, oldfile, flags=re.MULTILINE)
        if len(pattern_lines) == 0:
            open(filename, 'a').write(newline)
            return
        last_line = pattern_lines[-1]
        newfile = oldfile.replace(last_line, last_line + newline + '\n')
        open(filename, 'w').write(newfile)

def append_item_into_file(filename, linepattern, input_string):
    """
    Basically the same as append_re_line_sequence function, but it does not
    append anything when the input is not found 
    ---
    Detects the re 'linepattern' in the file. After its last occurrence,
    pastes the input string. If pattern doesn't exist
    notifies and leaves the file unchanged
    """
    oldfile = open(filename, 'r').read()
    lines = re.findall(linepattern, oldfile, flags=re.MULTILINE)
    if len(lines) == 0:
        print "Pattern {} not found. Could not write {} file".format(linepattern,oldfile)
        return
    else:
        last_line = lines[-1]
        newfile = oldfile.replace(last_line, last_line + input_string)
    open(filename, 'w').write(newfile)

def copy_sources(args):
    """
    takes the contents of the sources file (which should be only a list) and adds it to the RFNOC_OOT_SRCS variable
    of the oot_Makefile.srcs, to be included into the build process
    """
    oot_dir = args.include_dir
    oot_srcs_file = os.path.join(oot_dir,'rfnoc','fpga-src','Makefile.srcs')
    dest_srcs_file = os.path.join(os.getcwd(),'..','..','lib','rfnoc','oot_Makefile.srcs')
    srcs = compare(oot_srcs_file,dest_srcs_file)
    linepattern = re.escape('RFNOC_OOT_SRCS = $(addprefix\\\n')
    #patt_v = re.escape('RFNOC_SRCS = $(abspath $(addprefix $(BASE_DIR)/../lib/rfnoc/, \\\n')
    append_item_into_file(dest_srcs_file,linepattern,srcs[1])


def compare(file1,file2):
    """
    compares two files line by line, and returns the lines of file that were not found on the second
    The returned is a tuple item that can be accessed in the form of a list as tuple[0], where each line takes a position on the list
    or in a string as tuple [1].
    """
    notinside = []
    with open(file1,'r') as arg1:
        with open(file2,'r') as arg2:
            text1 = arg1.readlines()
            text2 = arg2.readlines()
            for item in text1:
                if item not in text2:
                    notinside.append(item)
    lists = notinside
    strings = ''.join(notinside)
    return (lists, strings)

def build(args):
    cwd = os.getcwd()
    build_dir = os.path.join(cwd,'..','..','top',args.target)#there is no x310 folder, so make sure to have a reduced target here [e300, x300]
    if (os.path.isdir(build_dir)):
        print "changing temporarily working directory to {0}".format(build_dir)
        os.chdir(build_dir)
        make_cmd = "make X300_RFNOC_HGS"
        try: 
            os.system(make_cmd)
        except subprocess.CalledProcessorError as e:
            print "Trouble building target at Makefile"
            exit(1)
        os.chdir(build_dir)

if __name__ == "__main__":
    args = setup_parser().parse_args()
    RFNOC_BLOCKS = create_env_var(args)
    env = create_rfnoc_env_script(RFNOC_BLOCKS)
    output = create_output(args)
    file_generator(args,output)
    copy_sources(args)
    os.environ = env #still not doing what I want, that is to leave the env with the variable RFNOC OOT there when the python script is done
    build(args)
   # if (len(args.outfile)):
   #     open(args.outfile,'w').write(output)
   # else:
   #     print output


